#+TITLE: tutorial-flutter
#+AUTHOR: Maxxcan Fox
#+EMAIL: maxxcan@disroot.org
#+DATE: <2020-09-28 lun>

* Introducción 

Flutter es un framework open source para crear alta calidad, alto desempeño aplicaciones móviles a través de sistemas operativos - Android e iOS. Proporciona un simple, potente, eficiente y fácil de entender SDK para escribir aplicaciones móviles en un lenguaje propio de Google, Dart. 

** Característica de Flutter

El framework Flutter ofrece las siguientes características a los desarrolladores - 

+ Un framework moderno y reactivo
+ Usa el lenguaje de programación Dart que es muy fácil de aprender 
+ Rápido desarrollo 
+ Bellos y fluidos interfaces de usuario 
+ Un amplio catálogo de widget. 
+ Ejecuta el mismo UI para múltiples plataformas 
+ Aplicaciones de alto desempeño 

** Ventajas de Flutter

Flutter viene con ellos y personalizables widgets para elevado desempeño y espectaculares aplicaciones móviles. Cumple todos las necesidades y requerimientos. Además de eso, Flutter ofrece muchas más ventajas que mencionaremos a continuación - 

+ Dart tiene un gran repositorio de paquetes de software los cuales permiten extender las capacidades de nuestra aplicación. 
+ Los desarrolladores necesitan escribir un código base para ámbas aplicaciones(Android e iOS). Flutter puede ser extendido a otras plataformas como son la web, o el escritorio en distintos sistemas operativos como son Linux, Windows o Mac. 
+ Flutter necesita menos testeo. Porque con su código base es suficiente si escribimos test automatizados para ámbas plataformas.
+ La simplicidad de Flutter hacer que sea un buen candidato para un desarrollo rápido. Su capacidad de personalización y extensión lo hace incluso más poderoso. 
+ Con Flutter, los desarrolladores tiene total control sobre los widgets y sus capas. 
+ Flutter ofrece grandes herramientas a los desarrolladores, con el increíble recarga en caliente. 

** Desventajas de Flutter 

A pesar de sus muchas ventajas, flutter tiene las siguientes desventajas - 

+ Como su código es en el lengauje Dart, un desarrollador tiene que aprender un nuevo lenguaje (aunque sea fácil de aprender).
+ Los modernos frameworks intentan separar la lógica y el UI tanto como sea posible pero, en Flutter, la interfaz de usuario y la lógica están intremezclados.  Podemos superar esto usando un código inteligente y usando un elevado nivel de módulos para separar la interfaz de usuario de la lógica. 
+ Flutter es todavía otro framework para crear aplicaciones móviles. Los desarrolladores tienen todavía un duro momento en elegir las correctas herramientas de desarrollo en tan grande segmento. 

* Arquitectura de una aplicación 

** Widgets 

El concepto fundamental de Flutter es que *en Flutter, todo es un Widget*. Los Widgets son básicamente componentes de la interfaz de usuario usados para crear la interfaz de usuario de la aplicación. 

En /Flutter/, la aplicación en sí misma es un widget. La aplicación es el widget de más alto nivel y su UI está construida usando uno o más widgets hijos, los cuales de nuevo están construidos usando sus widgets hijos. Esta *componibilidad* ayuda a crear una interfaz de usuario de cualquier complejidad. 

Por ejemplo, la jerarquía de una aplicación "hola mundo" seguiría el siguiente diagrama - 


[[./images/hello-world.png]]


Los puntos más notables - 

+ /MyApp/ es el widget creado por el usuario y está construido usando el widget nativo, /MaterialApp/. 
+ /MaterialApp/ tiene una propiedad /home/ que especifica la página de inicio, la cual es creada de nuevo por el widget /MyHomePage/
+ /MyHomePage/ está construida usando otro widget nativo, /Scaffold/
+ /Scaffold/ tiene dos propiedades - /body/ y /appBar/
+ /body/ es usada para espcificar la interfaz de usuario principal y /appBar/ es usada para especificar la cabecera de la interfaz
+ La cabecera está construida usando el widget /AppBar/ y el cuerpo está construido usando el widget /Center/
+ El widget /Center/ tiene una propiedad, /Child/, la cual refiere al Verdadero contenido y está construido usando el widget /Text/

** Gestos 

Los widgets de Flutter soportan la interacción a través de un widget especial, /GestureDetector/. /GestureDetector/ es un widget invisible que tiene la capacidad de capturar las interacciones del usuario tals como tocar la pantalla, arrastrar, etc, de su widget hijo. Muchos widgets nativos de Flutter soportar interacción a través del uso  de /GestureDetector/. Podemos también incorporar características de interacción dentro de un widget existente componiendo con el widget /GestureDetector/. 

** Concepto de Estado 

Los widgets de Flutter soportan el mantenimiento de Estado proporcionando un widget especial, /StatefulWidget/. El widget necesita ser derivado desde /StatefulWidget/ para soportar el mantenimiento de estado y todos los otros widget los otros widgets debería ser derivados desde /StatefulWidget/. Los widgets de Flutter son *reactivos* en nativo. Esto es similar a reactjs y /StatefulWidget/ será auto redibujado cada vez que el estado interno sea cambiado. El redibujado es optimizado para encontrar las diferencias entre el widget viejo y el nuevo y redibuja solo lo necesario. 

** Capas 

El concepto más importante de Flutter es que el framework está agrupado en múltiples categorias en terminos de complejidad y claramente organizado en capas de complejidad descendiente. Una capa está construida usando su inmediato próximo nivel de capa. La capa más alta es un widget específico de Android e iOS. La siguiente capa tienen todos los widgets nativos. La siguiente es la capa de dibujado, la cual es el más bajo nivel de componentes dibujados y dibuja todo en la aplicación de flutter. Capas hacia abajo llegamos al código específico del núcleo de la plataforma. 

El resumen general de una capa en Flutter está especificado en el siguiente diagrama - 

[[./images/layers.png]]


Los siguientes puntos resumen la Arquitectura de Flutter - 

+ En Flutter, todo es un widget y un widget complejo está compuesto por widgets que ya existen. 
+ Las Características interativas puder ser incorporadas cuando sean necesarias usando el widget /GestureDetector/.
+ El estado de un widget pueder mantenido en cuando sea necesario usando el widget /StatefulWidget/.
+ Flutter ofrecer capas de diseño, así que cualquier capa puede ser programada dependiendo de la complejidad de la tarea.


* Introducción a los Widgets 

Como ya hemos aprendido los widgets son todo en Flutter. En este capítulo, vamos a entender el verdadero concepto detrás de la creación de widgets y los diferentes tipos de widgtes que hay en Flutter. 

Vamos a echarle un vistazo al widget MyHomePage de la aplicación Hola Mundo - 

#+BEGIN_SRC dart
  class MyHomePage extends StatelessWidget {
    MyHomePage({Key key, this.title}) : super(key: key);

    final String title;
    @override 
    Widget build(BuildContext context){
      return Scaffold(
	appBar: AppBar(title: Text(this.title), ),
	body: Center(child: Text ('Hola Mundo',)),
      );
    }
  }
#+END_SRC

Aquí, hemos creado un nuevo widget por extensión de /StatelessWidget/. 

/StatelessWidget/ solo requiere un simple método de construcción para ser implementado en su clase derivada. El método /build/ obtiene el contexto del desarrollo necesario para construir los widgets a través del parámetro /BuildContext/ y devuleve el widget que se ha construido. 

En el código, hemos usado /title/ como uno de los argumentos el constructor y también hemos usado /Key/ como otro argumento. El /title/ es usada para mostrar el título y /Key/ es usado para identificar el widget en el entorno de construcción. 

Aquí, el método /build/ llama el método /build/ de /Scaffold/, el cual devuelve la llamada al método /build/ de /AppBar/ y /Center/ para construir al interfaz del usuario. 

Finalmente, /Center/ llamada al método /Text/.

Por un mejor entendimiento, la representación visual de ésto es dada a continuación - 

[[./images/representacion_visual.png]]



** Visualización del Widget Build 

En /Flutter/, los widgets pueder ser agrupados en múltiples categorias basados en sus características 

+ Widgets específicos de la plataforma 
+ Widgets de Capa
+ Widgets de mantenimiento de Estado 
+ Widgets básicos independientes de la plataforma 

Vamos a ver cada uno de ellos a continuación 

***   Widgets esspecíficos de la plataforma 

Flutter tiene widgets específicos para una plataforma en particular - Android o iOS.

Los widgets específicos para Android son diseñados conforme con /la guía de diseño Material/ por Android OS. Los widgets específicos para Android son llamados como /Material widgets/.

Los widgets específicos para iOS son diseñados conforme con la /Guía de Interfaz Humana/ de Apple y son llamados /Cupertino widgets/.

Algunos de los material widgets más usados son los siguientes - 

+ Scaffold 
+ AppBar
+ BottomNavigationBar
+ TabBar
+ TabBarView
+ ListTile
+ RaisedButton
+ FloatingActionButton
+ FlatButton
+ IconButton
+ DropdownButton
+ PopupenuButton
+ ButtonBar
+ TextField
+ Checkbox
+ Radio
+ Switch
+ Slider
+ Date & Time Pickers
+ SimpleDialog
+ AlertDialog

Algunos de los widgets /Cupertino/ más usados son los siguientes -

+ CupertinoButton
+ CupertinoPicker
+ CupertinoDatePicker
+ CupertinoTimePicker
+ CupertinoNavigationBar
+ CupertinoTabBar
+ CupertinoTabSCaffold
+ CupertinoTabView
+ CupertinoTextField
+ CupertinoDialog
+ CupertinoDialogAction
+ CupertinoFullscreenDialogTransition
+ CupertinoPageScaffold
+ CupertinoPageScaffold
+ CupertinoPageTransition
+ CupertinoActionSheet
+ CupertinoActivityIndicator
+ CupertinoAlertDialog
+ CupertinoPopupSurface
+ CupertinoSlider 

** Widgets de Capa  

En Flutter, un widget puder ser creado por composición de uno o más widgets. Para componer multiples widgets en un solo widget, /Flutter/ proporciona un gran número de widgets con características de capa. Por ejemplo, el widget /child/ puede ser centrado usando el widget /Center/. 

Algunos de los widgets de capa más populares son los siguientes - 

+ *Container* - Es una caja rectangular decorada usando el widget /BoxDecoration/ con fondo, borde y sombra. 
+ *Center* - Es un widget hijo
+ *Row* - Coloca sus hijos en dirección horizontal
+ *Column* - Coloca sus hijos en dirección vertical
+ *Stack* - Coloca uno sobre otro 

Veremos de forma más detenida estos widgets más adelante.

** Widgets de mantenimiento de Estado 

En Flutter, todos los widgets son derivados de StatelessWidget o StatefulWidget.

Los widgets derivados de StatelessWidget no tienen ninguna información de estado pero puede contener widget derivados de StatefulWidget. La naturaleza dinámica de la aplicación es a través del comportamiento interactivo de los widgets y que el estado cambie durante la interacción. Por ejemplo, tocar un botón contador que incrementa o decrementa el estado interno del contador por uno y la naturaleza reactiva de los widgets de Flutter que auto redibujará el widget usando la nueva información de estado. 

Aprenderemos el concepto de los widgets /StatefulWidget/ en detalle en el siguiente capítulo.

** Widgets independientes de plataforma y básicos  

/Flutter/ proporciona un amplio número de widgets básicos para crear tanto simples como complejos interfaces de usuario de una forma independiente de la plataforma. Veremos algunos widgets básicos en este capítulo. 

*** Text 

El widget /Text/ es usado para mostrar una pieza de texto. El estilo de la cadena de texto puede ser establecida usando la propiedad /style/ y la clase /TextStyle/. El código para este propósito es el que sigue - 

#+BEGIN_SRC dart 
Text('Hola Mundo', style: TextStyle(fontWeight: FontWeight.bold))
#+END_SRC

El widget /Text/ tiene un constructor especial, /Text.rich/, el cual acepta el hijo de tipo /TextSpan/ para especificar el texto con diferentes estilos. El widget /TextSpan/ es recursivo en naturaleza y acepta /TextSpan/ como su propio hijo. El código de ejemplo para este propósito es el siguiente - 

#+BEGIN_SRC dart 
  Text.rich(
    TextSpan(
      children: <TextSpan>[
	TextSpan(text: "Hola ", style:
	  TextStyle(fontStyle: FontStyle.italic)),
	TextSpan(text: "Mundo", style:
	  TextStyle(fontWeight: FontWeight.bold)),
      ],
    ),
  )
#+END_SRC

Las propiedades más importantes del widget /Text/ son las siguientes - 

+ *maxLines,int* Máximo número de líneas que mostrar
+ *overflow, TextOverFlow* - Especifica como es manejado el desborde, el cual es manejado por la clase /TextOverFlow/
+ *style, TextStyle* - Especifica el estilo de la cadena de texto usando la clase /TextStyle/
+ *textAlign, TextAlign* - Alineación del texto, derecha, izquirda, justificado, etc, usando la clase /TextAlign/
+ *textDirection, TextDirection* - Dirección del texto, puediendo elegir de izquierda a derecha o de derecha a izquierda

*** Image 

El widget /Image/ es usada para mostrar una imagen en la aplicación. El widget /Image/ proporciona diferentes constructores para cargar imagenes desde multiples fuentes y son los siguientes - 

+ *Image* - Cargador genérico de imágenes usando /ImageProvider/
+ *Image.asset* - Carga la imagen desde los recursos de un proyecto en Flutter
+ *Image.file* - Carga la imagen desde una carpeta del sistema 
+ *Image.memory* - Carga la imagen desde la memoria 
+ *Image.Network* - Carga la imagen desde la red 

La opción más fácil para cargar y mostrar una imagen en /Flutter/ es que sea includia en los recursos de la aplicación y cargarla en el widget bajo demanda. 

+ Crear una carpeta
+ Especificar el recurso en el fichero pubspec.yaml tal como se muestra a continuación 

#+BEGIN_SRC yaml
  flutter:
    assets:
      - assets/smiley.png
#+END_SRC

+ Ahora se carga y muestra la imagen en la aplicación. 

#+BEGIN_SRC dart 
  Image.asset('assets/smiley.png')
#+END_SRC

El código completo del widget /MyHomePage/ de la aplicación Hello World y el resultado se muestra a continuación - 

#+BEGIN_SRC dart 
  class MyHomePage extends StatelessWidget{
    MyHomePage({Key key, this.title}) : super(key: key);
    final String title;

    @override
    Widget build(BuildContext context){
      return Scaffold(
	appBar: AppBar( title: Text(this.title), ),
	body: Center( child: Image.asset("assets/smiley.png")),
      );
    }
  }
#+END_SRC

Esto preoducirá la siguiente - 

[[./images/smiley.png]]


Las propiedades más importantes del widget /Image/ son las siguientes - 

+ *image,ImageProvider* - La verdadera imagen a mostrar
+ *width,double* - Anchura de la imagen
+ *height,double* - Altura de la imagen
+ *alignment,AlignmentGeometry* - como se alinea la imagen respecto a su marco 

*** Icon  

El widget /Icon/ es usado para mostrar un glifo desde una fuente descrita por la clase /IconData/. El código para cargar un icon de email es el siguiente - 

#+BEGIN_SRC dart 
Icon(Icons.email)
#+END_SRC

El código completo aplicado a nuestra aplicación Hello World es el siguiente - 

#+BEGIN_SRC dart 
  class MyHomePage extends StatelessWidget{
    MyHomePage({Key key, this.title}) : super(key: key);
    final String title;

    @override
    Widget build(BuildContext context){
      return Scaffold (
	appBar: AppBar(title: Text(this.title),),
	body: Center (child: Icon(Icons.email)),
      );
    }
  }
#+END_SRC

Lo que mostrará nuestra aplicación será lo siguiente - 

[[./images/email.png]]


* Introducción a las capas  
  
Desde que el concepto central de /Flutter/ es que /Todo/ es un /widget/, /Flutter/ incorpora una funcionalidad de capa para la interfaz de usuario dentro de los widgets en sí mismo. /Flutter/ proporciona bastantes widgets especialmente diseñados como /Container/, /Center/, /Align/, etc, solo para le propósito de trabajar con capas en la interfaz de usuario. Los widgets construidos por composición de otros widgets normalmente usan widgets de capa. Vamos a aprender el concepto de capa en /Flutter/ en este capítulo. 

** Tipos de Widgets de Capa 

Los widgets de capa pueden ser agrupados en dos categorias distintas basados en sus hijos - 

+ Widgets que soportan un solo hijo 
+ Widgets que soportan multiples hijos 

Aprendamos ambos tipos de widgets y su funcionalidad en las siguientes secciones. 

** Widgets con un solo hijo 

En esta categoría, los widgets tendrán solo un widget como su hijo y cada widget tendrá una capa de funcionalidad especial. 

Por ejemplo, el widget /Center/ solo centra su widget hijo con respsecto a su widget padre y el widget /Container/ proporciona completa flexibilidad para localizar su hijo en cualquir lugar dado dentro de él usando diferentes opciones como padding, decoration, etc. 

Los widgets de un solo hijo son grandes opciones para crear widgets de alta calidad teniendo una sola funcionalidad tales como botones, etiquetas, etc. 

el código para crear un simple botón usando el widget /Container/ es el siguiente - 

#+BEGIN_SRC dart
  class MyButton extends StatelessWidget{
    MyButton({Key key}) : super(key: key);

    @override
    Widget build(BuildContext context){
      return Container(
	decoration: const BoxDecoration(
	  border: Border(
	    top: BorderSide(width: 1.0, color: Color(0xFFFFFFFFFF)),
	    left: BorderSide(width: 1.0, color: Color(0xFFFFFFFFFF)),
	    right: BorderSide(width: 1.0, color: Color(0xFFFF000000)),
	    bottom: BorderSide(width: 1.0, color: Color(0xFFFF000000)),
	  ),
	),
	child: Container(
	  padding: const
	  EdgeInsets.symmetric(horizontal: 20.0, vertical: 2.0),
	  decoration: const BoxDecoration(
	    border: Border(
	      top: BorderSide(width: 1.0, color: Color(0xFFFFDFDFDF)),
	      left: BorderSide(width: 1.0, color: Color(0xFFFFDFDFDF)),
	      right: BorderSide(width: 1.0, color: Color(0xFFFF7F7F7F)),
	    ),
	    color: Colors.grey,
	  ),
	  child: const Text(
	    'OK',textAlign: TextAlign.center, style: TextStyle(color: Colors.black)
	  ),
	),
      );
    }
  }
#+END_SRC 

Aquí, hemos usado dos widgets - un widget /Container/ y un widget /Text/. El resultado del widget es un botón a la medida como se ve a continuación - 

[[./images/ok.png]]


Comprobemos algunos de los más importantes widgets de un solo hijo proporcionados por /Flutter/ - 

+ *Padding* - Usado para ordenar su widget hijo con el relleno dado. Aquí, el relleno puede ser proporcionado por la clase /EdgeInsets/. 
+ *Align* - Alinea su widget hijo en sí mismo usando el valor de la propiedad /alignment/. El valor de la propiedad /alignment/ puede ser proporcionada por la clase /FractionalOffset/. La clase /FractionalOffset/ especifica la compensación en terminos de una distancia desde la parte de arriba a la izquierda. 

Algunos de los valores posibles de compensación son los siguientes - 

+ FractionalOffset(1.0, 0.0) representa la parte arriba derecha 
+ FractionalOffset(0.0, 1.0) representa la parte abajo izquierda.

Un código sobre las compensaciones (offsets) es mostrado a continuación - 

#+BEGIN_SRC dart 
  Center(
    child: Container(
      height: 100.0,
      width: 100.0,
      color: Colors.yellow, child: Align(
	alignment: FractionalOffset (0.2, 0.6),
	child: Container( height: 40.0, width:
	  40.0, color: Colors.red,
	),
      ),
    ),
  )
#+END_SRC

+ *FittedBox* - Escala el widget hijo y entonces lo posiciona acorde a un espacio especificado.
+ *AspectRatio* - Intenta cambiar el tamaño del widget hijo a una proporción especificada
+ ConstrainedBox
+ Baseline
+ FractinallySizedBox
+ IntrinsicHeight
+ IntrinsicWidth
+ LimitedBox
+ OffStage
+ OverflowBox
+ SizedBox
+ SizedOverflowBox
+ Transform
+ CustomSingleChildLayout

Nuestra aplicación Hello World está usando material basado en widgets de capa para diseñar la página principal. Modificaremos nuestra aplicación Hello World para construir la página principal usando widgets de capa básicos como especificamos antes - 

+ *Container* - Génerico, de hijo único, container basado en box con alineación, relleno, borde y márgen con Características de estilo ricas. 
+ *Center* - Simple, widget contenedor de hijo único, el cual centra su widget hijo. 

El código modificado del widget /MyHomePage/ y /MyApp/ es el siguiente - 

#+BEGIN_SRC dart 
  class MyApp extends StatelessWidget {
    @override
    Widget build(BuildContext context){
      return MyHomePage(title: "Hello World demo app");
    }
  }

  class MyHomepage extends StatelessWidget{
    MyHomePage({Key key, this.title}) : super(key: key);
    final String title;
    @override
    Widget build(BuildContext context){
      return Container(
	decoration: BoxDecoration(color: Colors.white,),
	padding: EdgeInsets.all(25), child: Center(
	  child: Text(
	    'Hello World', style: TextStyle(
	      color: Colors.black, letterSpacing: 0.5, fontSize: 20,
	    ),
	    textDirection: TextDirection.ltr,
	  ),
	)
      );
    }
  }
#+END_SRC 


Aquí 

+ Widget /Container/ está en lo más alto o widget raíz. /Container/ está configurado usando las propiedades /decoration/ y /padding/ para organizar su contenido.
+ /BoxDecoration/ tiene muchas propiedades como color, border, etc, para declarar el widget /Container/ y aquí, /color/ es usado para establecer el color del contenedor.
+ /padding/ del widget /Container/ es establecido usando la clase /IdgeInsets/, la cual proporciona la opción para especifica el valor de relleno. 
+ /Center/ es el widget hijo del widget /Container/. De nuevo, /Text/ es el hijo del widget /Center/. /Text/ es usada para mostrar el mensaje y /Center/ es usado para centrar el mensaje de texto con respecto a su widget padre, /Container/. 

El resultado final del código dado se muestra a continuación. 

[[./images/hola-final.png]]



** Widgets con múltiples hijos

En esta cateogoría, un widget dado tendrá más de un widget hijo y la capa de cada widget es única. 

Por ejemplo, el widget /Row/ permite la disposición de sus widgets hijos en dirección horizontal, mientras que el widget /Column/ permite disponerlos en dirección vertical. Por composición /Row/ y /Column/, los widget con cualquier nivel de complejidad pueden ser construidos. 

Aprendamos algunos de los widgets usados de forma más frecuente en esta sección. 

+ *Row* - Permite ordenar sus hijos de forma horizontal
+ *Column* - Permite ordenar a sus hijos de forma vertical
+ *ListView* - Permite ordenar a sus hijos como una lista
+ *GridView* - Permite ordenar a sus hijos como una galeria
+ *Expanded* - usado para hace que los hijos de los widgets Row y Column ocupen el máximo área posible
+ *Table* - Widget basado en tablas 
+ *Flow* - Widget basado en Flujo
+ *Stack* - Widget basado en pila 

** Aplicaciones de capa avanzados 

En esta sección, vammos a aprender como crear una interfaz de usuario compleja producto de listado con diseño personalizado usando tanto widgets de capa de un solo hijo como de múltiples. 

Para este propósito, seguiremos la secuencia que se muestra a continuación - 

+ Crear una nueav aplicación /Flutter/ 
+ Reemplazar el código de /main.dart/ por el siguiente 

#+BEGIN_SRC dart 
  import 'package:flutter/material.dart';
  void main() => runApp(MyApp());

  class MyApp extends StatelessWidget {
    //Este widget es la raíz de nuestra aplicación
    @override
    Widget build(BuildContext context){
      return MaterialApp(
	title: 'Flutter demo', theme: ThemeData(
	  primarySwatch: Colors.blue,
	),
	home: MyHomePage(title: 'Product layout Demo Homepage'),
      );
    }
  }

  class MyHomePage extends StatelessWidget{
    MyHomePage({Key key, this.title}) : super(key: key);
    final String title;

    @override
    Widget build(BuildContext context){
      return Scaffold(
	appBar: AppBar(title: Text(this.title),),
	body: Center(child: Text('Hello World',)),
      );
    }
  }
#+END_SRC

Aquí 

+ Hemos creado el widget /MyHomePage/ por extensión de /StatelessWidget/ en vez de /StatefulWidget/ y entonces hemos eliminado el código relevante.
+ Ahora, creamos un nuevo widget, /ProductBox/ acordando con el diseño especificado como se muestra a continuación - 

[[./images/productbox.png]]


El código de /ProductBox/ es el siguiente 

#+BEGIN_SRC dart 
  class Productox extends StatelessWidget{
    ProductBox({Key key, this.name, this.description, this.price, this.image}) :super(key: key);
    final String name;
    final String description;
    final int price;
    final String image;

    Widget build(BuildContext context){
      return Container(
	padding: EdgeInsetss.all(2), height: 120; child: Card(
	  child: Row(
	    mainAxisAlignment: MainAxisAlignment.spaceEvenly, children:<Widget>[
	      Image.asset("assets/appimages/" +image), Expanded(
		child: Container(
		  padding: EdgeInsets.all(5), child: Column(
		    mainAxisAlignment: MainAxisAlignment.spaceEVenly,
		    children: <Widget>[

		      Text(this.name, style: TextStyle(fontweight:
			  FontWeigth.bold)), Text(this.description),ºº
		      Text("Price: " + this.price.toString()),
		    ],
		  )
		)
	      )
	    ] 
	  )
	)
      );
    }
  }
#+END_SRC


Veamos el siguiente código 

+ /ProductBox/ ha sido usado por cuatro argumetnos especificados a continuación 
  + name - Nombre del producto
  + description - Descripción del producto
  + price - Precio del producto 
  + image - Imagen del producto

+ /ProductBox/ usa siete widgets que se especifican a continuación 
  + Container
  + Expanded
  + Row
  + Column
  + Card
  + Text 
  + Image

+ /ProductBox/ es diseñado usando el widget mencionado a continuación. La jerarquía del widget es especificada en el diagrama que se muestra a continuación - 

[[./images/jerarquia-producto.png]]


Ahora pondremos algunas imágenes falsas para la información del producto en la carpeta de las imagenes de la aplicación y configuraremos el archivo pubspec.yaml como se muestra

#+BEGIN_SRC yaml
  assets:
    - assets/appimages/floppy.png
    - assets/appimages/iphone.png
    - assets/appimages/laptop.png
    - assets/appimages/pendrive.png
    - assets/appimages/pixel.png
    - assets/appimages/tablet.png
#+END_SRC


Finalmente, usaremos el widget /ProductBox/ en el widget /MyHomePage/ como mostramos a continuación - 

#+BEGIN_SRC dart 
  class MyHomePage extends StatelessWidget{
    MyHomePage({key key, this.title}) : super(key: key);
    final String title;

    @override
    Widget build(BuildContext context){
      return Scaffold(
	appBar: AppBar(title: Text("Product Listing")),
	body: ListView(
	  shrinkWrap: true, padding: const EdgeInsets.fromLTRB(2.0, 10.0, 2.0, 10.0),
	  children: <Widget>[
	    ProductBox(
	      name: "iphone",
	      description: "iPhone is the stylist phone ever",
	      price: 1000,
	      image: "iphone.png"
	    ),
	    ProductBox(
	      name: "Pixel",
	      description: "Pixel is the most featureful phone ever",
	      price: 800,
	      image: "pixel.png"
	    ),
	    ProductBox(
	      name:"Laptop"
	      description:"Laptop is most productive development tool",
	      price:2000,
	      image:"laptop.png"
	    ),
	    ProductBox(
	      name:"Tablet",
	      description:"Tablet is the most useful device ever for meeting",
	      price:1500,
	      image:"tablet.png"
	    ),
	    ProductBox(
	      name:"Pendrive",
	      description:"Pendrie is useful storage medium",
	      price:100,
	      image:"pendrive.png"
	    ),
	    ProductBox(
	      name:"Floppy Drive",
	      description:"Floppy drive is useful rescue storage medium",
	      price:20,
	      image:"floppy.png"
	    ),
          
	  ],
	)
      );
    }
  }
#+END_SRC


Aquí, hemos usado /ProductBox/ como hijo del widget /ListView/.

El código completo (main.dart) de la aplicación (product_layout_app) es el siguiente - 

#+BEGIN_SRC dart 
  import 'package:flutteer/material.dart';
  void main() => runApp(MyApp());

  class MyApp extends StatelessWidget{
    // Este widget es la raíz de la aplicación.
    @override
    Widget build(BuildContext context){
      return MaterialApp(
	title: 'Flutter Demo', theme: ThemeData(
	  primarySwatch: Colors.blue,
	),
	home: MyHomePage(title: 'Product layout demo home page'),
      );
    }
  }

  class MyHomePage extends StatelessWidget{
    MyHomePage({Key key, this.title}) : suer(key: key);
    final String title;

    @override
    Widget build(BuildContext context){
      return Scaffold(
	appBar: AppBar(title: Text("Product Listing")),
	body: ListView(
	  shrinkWrap: true,
	  padding: const EdgeInsets.fromLTRB(2.0, 10.0, 2.0, 10.0),
	  children: <Widget>[
	    ProductBox(
	      name: "IPhone",
	      description:"Iphone es the stylist phone ever",
	      price:1000,
	      image:"iphone.png"
	    ),
	    ProductBox(
	      name:"Pixel",
	      description:"Pixel is the most featureful phone ever"
	      price:800,
	      image:"pixel.png"
	    ),
	    ProductBox(
	      name:"Laptop",
	      description:"Laptop is most productive development tool",
	      price:2000,
	      image:"laptop.png"
	    ),
	    ProductBox(
	      name:"Tablet"
	      description:"Tablet is the most useful device ever for meeting",
	      price:1500,
	      image:"tablet.png"
	    ),
	    ProductBox(
	      name:"Pendrive",
	      description:"Pendrive is useful storage medium",
	      price:100,
	      image:"pendrive.png"
	    ),
	    ProductBox(
	      name:"Floppy Drive",
	      description:"Floppy drive is useful rescue storage medium",
	      price:20,
	      image:"floppy.png"
	    ),
          
	  ]
	)
      );
    }
  }

  class ProductBox extends StatelessWidget{
    ProductBox({Key key, this.name, this.description, this.price, this.image}) : suepr(key: key);
    final String name;
    final String description;
    final int price;
    final String image;

    Widget build(BuildContext context){
      return Container(
	padding: EdgeInsets.all(2),
	height: 120,
	child: Card(
	  child: Row(
	    mainAxisAlignment: MainAxisAlignment.spaceEvenly,
	    children: <Widget>[
	      Image.asset("assets/appimages/" + image),
	      Expanded(
		child: Container(
		  padding: EdgeInsets.all(5),
		  child: Column(
		    mainAxisAlignment: MainAxisAlignment.spaceEvenly,
		    children: <Widget>[
		      Text(
			this.name, style: TextStyle(
			  fontWeight: FontWeight.bold
			)
		      ),
		      Text(this.description), Text(
			"Price: " + this.price.toString()
		      ),
		    ],
		  )
		)
	      )
	    ]
	  )
	)
      );
    }
  }

#+END_SRC


El resultado final será el siguiente - 

[[./images/producto-final.png]]


* Introducción a los Gestos 

Los /Gestos/ son primariamente una forma para que un usuario pueda interactuar con una aplicación para  móvil (o cualquier dispositivo basado en tacto). Los Gestos son generalmente definidos como cualquier acción física o movimiento de un usuario con la inteción de activar un control específico del dispositivo móvil. Los Gestos son tan simples como tocar la pantalla del dispositivo móvil o acciones más complejas usadas en juegos. 

Algunos de los gestos más usados son mencionados aquí - 

+ *Tap* Tocar la superfice del dispositivo con la punta de los dedos por un periodo corto. 
+ *Double Tap* - Tocar la pantalla en un corto espacio de tiempo.
+ *Drag* - Tocar la superficie del dispositivo con la punta del dedo y entonces moverlo de forma constante hasta volver a levantar el dedo.
+ *Flick* - Similar a arrastrar (drag) pero haciendolo de forma más rápida.
+ *Pinch* - Pellizcar la superfice del dispositivo usando dos dedos.
+ *Spread/Zoom* - Lo contrario que pellizcar (Pinch).
+ *Panning* - Tocar la superfice del dispositivo con la punta del dedo y moverlo en cualquier direccion sin levantar el dedo.

/Flutter/ proporciona un excelente soporte para todos los tipos de gestos a través del widget exclusivo, *GestureDetector*. GestureDetector es un widget no invisible primariamente usado para detectar los gestos del usuario. Para identificar un gesto enfocado en un widget, el widget puede ser localizado dentro del widget GestureDetector. GestureDetector capturará el gesto y enviará múltiples eventos basados en el gesto. 

Algunos de los gestos y su correspondiente evento se muestran a continuación - 

+ Tap 
  + onTapDown
  + onTapUp
  + onTap 
  + onTapCancel
+ Double Tap
  + onDoubleTap
+ Long press 
  + onLongPress
+ Vertical drag 
  + onVerticalDragStart
  + onVerticalDragUpdate
  + onVerticalDragEnd
+ Horizontal drag
  + onHorizontalDragStart
  + onHorizontalDragUpdate
  + onHorizontalDragEnd
+ Pan 
  + onPanStart
  + onPanUpdate
  + onPanEnd

Ahora vamos a modificar la aplicación Hello World para incluir la detección de gestos e intentar entender el concepto. 

+ Cambiar el contenido del cuerpo del widget /MyHomePage/ como se muestra a continuación - 

#+BEGIN_SRC dart 
  body: Center(
    child: GestureDetector(
      onTap: (){
	_showDialog(context);
      },
      child: Text('Hello World'.)
    )
  ),
#+END_SRC

+ Observemos que aquí hemos puesto el widget /GestureDetector/ sobre el widget /Text/ en la jerarquía de widgets, capturando el evento Tap y entonces Finalmente mostrarmoss una ventana de diálogo. 
+ Implementamos la función *_showDialog* para presentar un cuadro de diálogo cuando pulsemos el mensaje de /hello world/. Éste usa los widgets genéricos /showDialog/ y /AlertDialog/ para crear un nuevo widget de cuadro de diálogo. Es código es el siguiente - 

#+BEGIN_SRC dart 
  // función vacía definida por el usuario _showDiaglo(BuildContext context)
  showDialog(
    context: context, builder: (BuildContext context){
      //devuelve objeto de tipo dialogo
      return AlertDialog(
	title: new Text("Message"),
	content: new Text("Hello World"),
	actions: <Widget>[
	  new Flatbutton(
	    child: new Text("Close"),
	    onPressed: (){
	      Navigator.of(context).pop();
	    }
	  )
	]
      );
    }
  )

#+END_SRC

+ El resultado es el siguiente - 


[[./images/gesture_helloworld.png]]


El código completo (main.dart) es el siguiente - 


#+BEGIN_SRC dart 
  import 'package:flutter/material.dart';
  void main() => runApp(MyApp());

  class MyApp extends StatelessWidget{
    // este widget es la raíz de la app.
    @override
    Widget build(BuildContext context){
      return MaterialApp(
	title: 'Hello World Demo Application',
	theme: ThemeData( primarySwatch: Colors.blue,),
	home: MyHomePage(title: 'Home Page'),
      );
    }
  }

  class MyHomePage extends StatelessWidget{
    MyHomePage({Key key, this.title}) : super(key: key);
    final String title;

    //función definida por el usuario
    void _showDialog(BuildContext context){
      //función showDialog
      contexxt: context, builder: (BuildContext context){
	// devuelve obbjeto de tipo Dialog devolviendo AlertDialog
	title: new Text("Message"),
	context: new Text("Hello World"),
	actions: <Widget>[
	  new FlatButton(
	    child: new Text("Close"),
	    onPressed: ()(
	      Navigator.of(context).pop();
	    ),
	  ),
	],
      };
    },
  }

  @override
  Widget build(BuildContext context){
    return Scaffold (
      appBar: AppBar(title: Text(this.title),),
      body: Center(
	child: GestureDetector(
	  onTap: (){
	    _showDialog(context);
	  },
	  child: Text('Hello World',)
	)
      )
    );
  }
#+END_SRC

Finalmente, /Flutter/ también proporciona deteción de gestor de bajo nivel a través del widget /Listener/. Éste detectará todas las intercciones del usuario y entonces disparará los siguientes eventos - 

+ PointerDownEvent
+ PointerMoveEvent
+ PointerUpEvent
+ PointerCancelEvent

/Flutter/ también proporciona un pequeño conjunto de widgets para gestos avanzados. Estos widgets son - 

+ *Dismissible* - Soporta gestor de sacudir para descartar el widget 
+ *Draggable* - Soporta el gesto de arrastrar para movere el widget 
+ *LongPressDraggable* - Soporta el gesto de arrastrar para mover un widget cuando sus padres también son arrastrables
+ *IgnorePointer* - Esconde el widget y sus hijos del proceso de detección de gestos
+ *AbsorbPointer* - Para la detección de gestos de sí mismo y también cualquier widget solapado puede tamién no ser capaz de participar en la detección de gestos. 
+ *Scrollable* - Soporta ek desplazamiento del contenido dentro del widget 

* Flutter - Manejo del Estado 

Manejar el estado en una aplicación es uno de los procesos más importantes y necesarios en el ciclo de vida de una aplicación. 

Consideremos un simple carrito de la compra en una aplicación. 

+ El usuario se logueará usando sus credenciales. 
+ Una vez el usuario esté logueado, la aplicación persitirá el estado de logueado en todas las pantallas. 
+ De nuevo, cuando el usuario seleccione un producto y lo salve en un carrito, la información del carro debe persistir entre las página hasta que el usuario compruebe el carrito. 
+ El usuario y la información de su carrito en cualquier instancia es llamado por el estado de la aplicación y esa instancia. 

Una gestión del estado puede ser dividida en dos categorías

+ Efímero - Dura por unos pocos segundos como el estado actual de un animación o una sola página como la puntuación de un producto. /Flutter/ soporta esto a través de /StatefulWidget/. 
+ Estado de la app - Dura para la apliación entera como cuando un usuario se loguea, información del carrito, etc. /Flutter/ soporta esto a través del /scoped_movil/. 

** Navegación y enrutamiento

En cualquier aplicación, navegar de una página/pantalla a otra define el flujo de trabajo de la aplicación. La forma en la que una aplicación es manejada es llamada enrutamiento. /Flutter/ proporciona una clásica básica para esto - /MaterialPageRoute/ y dos métodos - /Navigator.push/ y /Navigator.pop/ para definir el flujo de trabajo de una aplicación. 

*** MaterialPageRoute 

/MaterialPageRoute/ es un widget usado para dibujar su UI por reemplazamiento de la pantalla entera con una animación específica de la plataforma. 

: MaterialPageRoute(builder: (context) => Widget())

Aquí, builder acepta una función para construir su contenido suplantando el contexto actual de la aplicación. 

*** Navigation.push 
/Navigation.push/ es usado para navegar a una nueva pantalla usando el widget /MaterialPageRoute/. 

: Navigator.push( context, MaterialPageRoute(builder: (context) => Widget()), );

*** Navigation.pop 

/Navigation.pop/ es usado para navegar a una pantalla previa. 

: Navigator.pop(context);

Vamos a crear una nueva aplicación para entender mejor el concepto de navegar.

Crearemos una nueva aplicación /Flutter/, product_nav_app. 

+ Copiamos la carpeta de los rescursos desde product_nav_app a product_state_app y añadimos los recursos dentro del archivo pubspec.yaml. 

#+BEGIN_SRC yaml
  flutter:
    assets:
      - assets/appimages/floppy.png
      - assets/appimages/iphone.png
      - assets/appimages/laptop.png
      - assets/appimages/pendrive.png
      - assets/appimages/pixel.png
      - assets/appimages/tablet.png
#+END_SRC

+ Reemplazamos el código que viene por defecto y añadimos nuestro código en main.dart 

#+BEGIN_SRC dart 
  import 'package:flutter/material.dart';
  void main() => runApp(MyApp());

  class MyApp extends StatelessWidget{
    @override
    Widget build(BuildContext context){
      return MaterialApp(
	title: 'Flutter Demo',
	theme: ThemeData(
	  primarySwatch: Colors.blue,
	),
	home: MyHomePage(
	  title: 'Product state demo home page',
	),
      );
    }
  }

  class MyHomePage extends StatelessWidget{
    MyHomePage({Key key, this.title}) : super(key: key);
    final Stirng title;
    @override
    Widget build(BuildContext context){
      return Scaffold(
	appBar: AppBar(
	  title: Text(this.title),
	),
	body: Center(
	  child: Text("Hello World"),
	),
      );
    }
  }

#+END_SRC


Ahora crearemos una clase Product para organizar la información de los productos. 

#+BEGIN_SRC dart 
class Product{
final String name;
final String description;
final int price;
final String image;
Product(this.name, this.description, this.price, this.image);
}
#+END_SRC

Escribiremos un método getProducts en la clase Product para generar nuestro registro de productos falso. 

#+BEGIN_SRC dart 
  static List<Product> getProducts(){
    List<Product> items = <Product>[];

    items.add(
      Product(
	"Pixel",
	"Pixel is the ost feature-full phone ever", 800,
	"pixel.png"
      )
    );
    items.add(
      Product(
	"Laptop",
	"Laptop is most productive development tool",
	200, "laptop.png"
      )
    );
    item.add(
      Product(
	"Tablet",
	"Tablet is the most useful device ever for meeting",
	1500,
	"tablet.png"
      )
    );
    items.add(
      Product(
	"Pendrive",
	"Pendrive is useful storage medium",
	100,
	"pendrive.png"
      )
    );
    items.add(
      Product(
	"Floppy Drive",
	"Flopyy drive is useful rescue storage medium",
	20,
	"floppy.png"
      )
    );
    return items;
  }
  import product.dart in main.dart
  import 'Product.dart';
#+END_SRC

Vamos a incluir nuestro nuevo widget, /RatingBox/.

#+BEGIN_SRC dart 
  class RatingBox extends StatefulWidget {
    @override
    _RatingBoxState createState() => _RatingBoxState();
  }

  class _RatingBoxState extens State<RatingBox>{
    int _rating = 0;
    void _setRatingAsOne(){
      setState((){
	  _rating = 1;
      });
    }
    void _setRatingAsTwo(){
      setState(() {
	  _rating = 2;
      });
    }
    void _setRatingAsThree(){
      setState(() {
	  _rating = 3;
      });
    }

    Widget build(BuildContext context){
      double _size = 20;
      print(_rating);
      return Row(
	mainAxisAlignment: MainAxisAlignment.end,
	crossAxisAlignment: CrossAxisAlignment.end,
	mainAxisSize: MainAxisSize.max,
	children: <Widget>[
	  Container(
	    padding: EdgeInsets.all(0),
	    child: IconButton(
	      icon: (
		_rating >= 1?
		Icon(
		  Icons.star,
		  size: _size,
		)
		: Icon(
		  Icons.star_border,
		  size: _size,
		)
	      ),
	      color: Colors.red(500),
	      onPressed: _setRatingAsOne,
	      iconSize: _size,
	    ),
	  ),
	  Container(
	    padding: EdgeInsets.all(0),
	    child: IconButton(
	      icon: (
		_rating >= 2?
		Icon(
		  Icons.star,
		  size: _size,
		)
		: Icon(
		  Icons.star_border,
		  size: _size,
		)
	      ),
	      color: Colors.red(500),
	      onPressed: _setRatingAsTwo,
	      iconSize: _size,
	    ),
	  ),
	  Container(
	    padding: EdgetInsets.all(0),
	    child: IconButton(
	      icon: (
		_rating >=3?
		Icon(
		  Icons.star,
		  size: _size,
		)
		: Icon(
		  Icons.star_border,
		  size: _size,
		)
	      ),
	      color: Colors.red(500),
	      onPressed: _setRatingAsThree,
	      iconSize: _size,
	    ),
	  ),
	],
      );
    }
  }
#+END_SRC

Ahora vamos a modificar nuestro widgeet /ProductBox/ para que funcione con nuestra nueva clase /Product/. 

#+BEGIN_SRC dart 
  class ProductBox extends StatelessWidget{
    ProductBox({Key key, this.item}) : super(key: key);
    final Product item;

    Widget build(BuildContext context){
      return Container(
	padding: EdgeInsets.all(2),
	height: 140,
	child: Card(
	  child: Row(
	    mainAxisAlignment: MainAxisAlignment.spaceEvenly,
	    children: <Widget>[
	      Image.asset("assets/appimages/" + this.item.image),
	      Expanded(
		child: Container(
		  padding: EdgeInsets.all(5),
		  child: Column(
		    mainAxisAlignment: MainAxisAlignment.spaceEvenly,
		    children: <Widget>[
		      Text(this.item.name,
			stye: TextStyle(fontWeight: FontWeight.bold)),
		      Text(this.item.description),
		      Text("Price: " + this.item.price.toString()),
		      RatingBox(),
		    ],
		  )
		)
	      )
	    ]
	  ),
	)
      );
    }
  }
#+END_SRC


Vamos a reescribir nuestro widget /MyHomePage/ para que funcione con el modelo /Product/ y liste todos los productos usando /ListView/.

#+BEGIN_SRC dart 
  class MyHomePage extends StatelessWidget {
    MyHomePage({Key key, this.title}) : super(key: key);
    final String title;
    final items = Product.geetProducts();

    @override
    Widget build(BuildContext context){
      return Scaffold(appBar: AppBar(title: Text("Product Navigation")),
	body: ListView.builder(
	  itemCount: items.length,
	  itemBuilder: (context, index){
	    return GestureDetector(
	      child: ProductBox(item: items[items]),
	      onTap: () {
		Navigator.push(
		  context, MaterialPageRoute(
		    builder: (context) => ProductPage(item: items [index]),
		  ),
		);
	      },
	    );
	  },
      ));
    }
  }
#+END_SRC


Hemos usado /MaterialPageRoute/ para navegar a la página de detalles de producto. 

Ahora, vamos a añadir /ProductPage/ para mostrar el detalle del producto. 

#+BEGIN_SRC dart 
  class ProductPage extends StatelessWidget {
    ProductPage({Key key}) : super(key: key);
    final Product item;

    @override
    Widget build(BuildContext context){
      return Scaffold(
	appbar: AppBar(
	  title: Text(this.item.name),
	),
	body: Center(
	  child: Container(
	    padding: EdgeInsets.all(0),
	    child: Column(
	      mainAxisAlignment: MainAxisAlignment.start,
	      crossAxisAlignment: CrossAxisAlignment.start,
	      children: <Widget>[
		Image.asset("assets/appimages/" + this.item.image),
		Expanded(
		  child: Container(
		    padding: EdgeInsets.all(5),
		    child: Columns(
		      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
		      children: <Widget>[
			Text(
			  this.item.name, style: TextStyle(
			    fontWeight: FontWeight.bold
			  )
			),
			Text(this.item.description),
			Text("Price: " + this.item.price.toString()),
			RatingBox,
		      ],
		    )
		  )
		)
	      ]
	    ),
	  ),
	),
      );
    }
  }
#+END_SRC


El código completo de la aplicación es el siguiente - 

#+BEGIN_SRC dart 
import 'package:flutter/material.dart'; 
void main() => runApp(MyApp()); 

class Product {
   final String name; 
   final String description; 
   final int price; 
   final String image; 
   Product(this.name, this.description, this.price, this.image); 
   
   static List<Product> getProducts() {
      List<Product> items = <Product>[]; 
      items.add(
         Product(
            "Pixel", 
            "Pixel is the most featureful phone ever", 
            800, 
            "pixel.png"
         )
      );
      items.add(
         Product(
            "Laptop", 
            "Laptop is most productive development tool", 
            2000, 
            "laptop.png"
         )
      ); 
      items.add(
         Product(
            "Tablet", 
            "Tablet is the most useful device ever for meeting", 
            1500, 
            "tablet.png"
         )
      ); 
      items.add(
         Product( 
            "Pendrive", 
            "iPhone is the stylist phone ever", 
            100, 
            "pendrive.png"
         )
      ); 
      items.add(
         Product(
            "Floppy Drive", 
            "iPhone is the stylist phone ever", 
            20, 
            "floppy.png"
         )
      ); 
      items.add(
         Product(
            "iPhone", 
            "iPhone is the stylist phone ever", 
            1000, 
            "iphone.png"
         )
      ); 
      return items; 
   }
}
class MyApp extends StatelessWidget {
   // This widget is the root of your application. 
   @override 
   Widget build(BuildContext context) {
      return MaterialApp(
         title: 'Flutter Demo', 
         theme: ThemeData( 
            primarySwatch: Colors.blue, 
         ), 
         home: MyHomePage(title: 'Product Navigation demo home page'), 
      ); 
   }
}
class MyHomePage extends StatelessWidget {
   MyHomePage({Key key, this.title}) : super(key: key); 
   final String title; 
   final items = Product.getProducts(); 
   
   @override 
   Widget build(BuildContext context) {
      return Scaffold(
         appBar: AppBar(title: Text("Product Navigation")), 
         body: ListView.builder( 
            itemCount: items.length, 
            itemBuilder: (context, index) { 
               return GestureDetector( 
                  child: ProductBox(item: items[index]), 
                  onTap: () { 
                     Navigator.push( 
                        context, 
                        MaterialPageRoute( 
                           builder: (context) => ProductPage(item: items[index]), 
                        ), 
                     ); 
                  }, 
               ); 
            }, 
         )
      ); 
   }
} 
class ProductPage extends StatelessWidget {
   ProductPage({Key key, this.item}) : super(key: key); 
   final Product item; 
   
   @override 
   Widget build(BuildContext context) {
      return Scaffold(
         appBar: AppBar(
            title: Text(this.item.name), 
         ), 
         body: Center(
            child: Container( 
               padding: EdgeInsets.all(0), 
               child: Column( 
                  mainAxisAlignment: MainAxisAlignment.start, 
                  crossAxisAlignment: CrossAxisAlignment.start, 
                  children: <Widget>[ 
                     Image.asset("assets/appimages/" + this.item.image), 
                     Expanded( 
                        child: Container( 
                           padding: EdgeInsets.all(5), 
                           child: Column( 
                              mainAxisAlignment: MainAxisAlignment.spaceEvenly, 
                              children: <Widget>[ 
                                 Text(this.item.name, style: TextStyle(fontWeight: FontWeight.bold)), 
                                 Text(this.item.description), 
                                 Text("Price: " + this.item.price.toString()), 
                                 RatingBox(), 
                              ], 
                           )
                        )
                     ) 
                  ]
               ), 
            ), 
         ), 
      ); 
   } 
}
class RatingBox extends StatefulWidget { 
   @override 
   _RatingBoxState createState() => _RatingBoxState(); 
} 
class _RatingBoxState extends State<RatingBox> { 
   int _rating = 0;
   void _setRatingAsOne() {
      setState(() {
         _rating = 1; 
      }); 
   }
   void _setRatingAsTwo() {
      setState(() {
         _rating = 2; 
      }); 
   } 
   void _setRatingAsThree() { 
      setState(() {
         _rating = 3; 
      }); 
   }
   Widget build(BuildContext context) {
      double _size = 20; 
      print(_rating); 
      return Row(
         mainAxisAlignment: MainAxisAlignment.end, 
         crossAxisAlignment: CrossAxisAlignment.end, 
         mainAxisSize: MainAxisSize.max, 
         children: <Widget>[
            Container(
               padding: EdgeInsets.all(0), 
               child: IconButton(
                  icon: (
                     _rating >= 1 ? Icon( 
                        Icons.star, 
                        size: _size, 
                     ) 
                     : Icon( 
                        Icons.star_border, 
                        size: _size, 
                     )
                  ), 
                  color: Colors.red[500], 
                  onPressed: _setRatingAsOne, 
                  iconSize: _size, 
               ), 
            ), 
            Container(
               padding: EdgeInsets.all(0), 
               child: IconButton( 
                  icon: (
                     _rating >= 2 ? 
                     Icon( 
                        Icons.star, 
                        size: _size, 
                     ) 
                     : Icon( 
                        Icons.star_border, 
                        size: _size, 
                     )
                  ), 
                  color: Colors.red[500], 
                  onPressed: _setRatingAsTwo, 
                  iconSize: _size, 
               ), 
            ), 
            Container(
               padding: EdgeInsets.all(0), 
               child: IconButton(
                  icon: (
                     _rating >= 3 ? 
                     Icon( 
                        Icons.star, 
                        size: _size, 
                     )
                     : Icon( 
                        Icons.star_border, 
                        size: _size, 
                     )
                  ), 
                  color: Colors.red[500], 
                  onPressed: _setRatingAsThree, 
                  iconSize: _size, 
               ), 
            ), 
         ], 
      ); 
   } 
} 
class ProductBox extends StatelessWidget {
   ProductBox({Key key, this.item}) : super(key: key); 
   final Product item; 
   
   Widget build(BuildContext context) {
      return Container(
         padding: EdgeInsets.all(2), 
         height: 140, 
         child: Card(
            child: Row(
               mainAxisAlignment: MainAxisAlignment.spaceEvenly, 
               children: <Widget>[ 
                  Image.asset("assets/appimages/" + this.item.image), 
                  Expanded( 
                     child: Container( 
                        padding: EdgeInsets.all(5), 
                        child: Column( 
                           mainAxisAlignment: MainAxisAlignment.spaceEvenly, 
                           children: <Widget>[ 
                              Text(this.item.name, style: TextStyle(fontWeight: FontWeight.bold)), Text(this.item.description), 
                              Text("Price: " + this.item.price.toString()), 
                              RatingBox(), 
                           ], 
                        )
                     )
                  ) 
               ]
            ), 
         )
      ); 
   } 
}

#+END_SRC

Cuando ejecutemos la aplicación y pinchemos en uno de los productos, se mostrará la página de detalle del produccto. Podemos volver a la página de inicio pinchando en el botón de vuelta. La página de lista de productos y la página de los detalles del producto se muestran a continuación. 

[[./images/pagina_producto.png]]


[[./images/detalle-producto.png]]


* Flutter - Animación 

La animación es un procedimiento complejo en cualquier aplicación móvil. A pesar de esta complejidad, la Animación mejora la experiencia del usuario a un nuevo nivel y proporciona una interacción rica con el usuario. Previsto a esta riqueza, la animación se convierte en un parte integral de las aplicaciones móviles modernas. El framework /Flutter/ reconoce la importancia de la animación y proporciona un framework simple e intuitivo para desarrollar todo tipo de animaciones. 

** Introducción 

La animación es un proceso que muestra una serie de imágenes en un orden particular con una duración específica para dar la sensación de movimiento. El aspecto más importante de la animación es lo siguiente - 

+ La animación tiene dos valores distintos: Valor de Inicio y valor Final. La animación empieza desde el valor de Inicio y va a través de una serie de valores intermedios y Finalmente termina en el valor Final. Por ejemplo, para animar un widget que desaparezca, el valor inicial será la opacidad total y el valor final será la cero opacidad. 

+ Los valoress intermedios pueden ser lineales o no-lineales (curva) y pueden ser configurados. Ententiendo qu la animación funciona como esté configurada. Cada configuración proporciona una sensación diferente a la animación. Por ejemplo, un widget que desaparece será linear mientras que el bote de una pelota no lo será. 

+ La duración del proceso de animación afecta la velocida (más rápido o más lento) de la animación. 

+ La habilidad para controlar el proceso de la animación como el inicio de la animación, la parada, la repetición un número de veces, el proceso de retroceso, etc.

+ En /Flutter/, el sistema de animación no hacer una animación real. En vez de eso, proporciona solo los valores requeridos a cada cuadro para dibujar las imágenes. 

** Clases para la animación 

El sistema de animación de /Flutter/ está basado en objetos animados. El núcleo de las clases para la animación y su uso es el siguiente - 

***  Animation 

Genera valores intermedios entre dos valores de una cierta duración. Las clases más comunes son - 

+ *Animation<double>* - Intercala valores entre dos números decimales
+ *Animation<Color>* - Intercala colores entre dos colores 
+ *Animation<Size>* - Intercala tamaños entre dos tamaños 
+ *AnimationController* - Objeto especial de animación para controlar la animación en sí misma. Genera nuevos valores cuando la aplicación esté preparada para un nuevo cuadro. Soporta animación linear y los valores empiezan desde 0.0 hasta 1.0

#+BEGIN_SRC dart 
controller = AnimationController(duration: cont Duration(secons: 2), vsync: this);
#+END_SRC



*** CurvedAnimation 

Similar a AnimationController pero soporta animación no-linear. CurvedAnimation puede ser usada con objetos de animación tal como sigue - 

#+BEGIN_SRC dart 
controller = AnimationController(duration: const Duration(seconds: 2), vsync: this);
animation = CurvedAnimation(parent: controller, curve: Curves.easeIn)
#+END_SRC

*** Tween<T>

Derivado de Animatable<T> y usado para generar números entre dos números además de 0 y 1. Puede ser usado junto con objetos de Animación usando el método animate y pasando el verdadero objeto Animation. 

#+BEGIN_SRC dart 
  AnimationController controller = AnimationController(
    duration: const Duration(milliseconds: 1000),
    vsync: this); Animation<int> customTween = IntTween(
    begin: 0, end: 255).animate(controller);
  )
#+END_SRC

+ Tween puede usarse junto con CurvedAnimation - 

#+BEGIN_SRC dart 
  AnimationController controller = AnimationController(
    duration: const Duration(milliseconds: 500), vsync: this);
  final Animation curve = CurvedAnimation(parent: controller, curve: Curves.easeOut);
  Animation<Int> customTween = IntTween(begin: 0, end: 255).animate(curve);
#+END_SRC

Aquí, controller es el verdadero cotrolador de la animación. La curva proporciona el tipo de no-linear y el customTween proporciona el rango desde 0 a 255.

** Flujo de trabajo de la Animación en Flutter 

El flujo de trabajo de la animación es el siguiente - 

+ Definir y empezar el controlador de la animación en el initState del StatefulWidget. 

#+BEGIN_SRC dart 
AnimationController(duration: const Duration(seconds: 2), vsync: this);
animation = Tween<double>(begin: 0, end: 300).animate(controller);
controller.forward();
#+END_SRC

+ Añadir un escuchante con addListener para cambiar el estado del widget. 

#+BEGIN_SRC dart 
  animation = Tween<double>(begin: 0, end: 300).animate(controller) .addListener(() {
      setState(() {
	  // El estado que ha cambiado aquí es el valor del objeto animación
      });
  });
#+END_SRC

+ Widgets empotrados, AnimatedWidget y AnimatedBuilder pueden ser usados para escapar de este proceso. Ámbos widgets aceptan objetos de Animación y obtienen los valores requeridos para la animación. 

+ Obtener los valores de la animación durante el proceso de construcción del widget y entonces aplicarlo para ancho, alto o cualquier propiedad relevante en vez del valor original. 

#+BEGIN_SRC dart 
  child: Container(
    height: animation.value,
    width: animation.value,
    child: <Widget>,
  )
#+END_SRC

** Aplicación funcionando 

Vamos a escribir una animación simple basada en la aplicación para entender el concepto de la animación en /Flutter/. 

+ Creamos una nueva aplicación /Flutter/ llamada, product_animation_app. 
+ Copiamos los recursos de la carpeta asset desde product_nav_app a product_animation_app y añadimos esos recursos dentro del archivo pubspec.yaml 

#+BEGIN_SRC yaml 
  flutter :
    assets:
      - assets/appimages/floppy.png
      - assets/appimages/iphone.png
      - assets/appimages/laptop.png
      - assets/appimages/pendrive.png
      - assets/appimages/pixel.png
      - assets/appimages/tablet.png
    
#+END_SRC

+ Eliminamos el código que viene por defecto en main.dart 
+ Añadimos e importamos lo básico 

#+BEGIN_SRC dart 
import 'package:flutter/material.dart';
void main() => runApp(MyApp());
#+END_SRC

+ Creamos el widget MyApp derivado de StatefulWidget

#+BEGIN_SRC dart 
  class MyApp extends StatefulWidget (
    _MyAppState createState() => _MyAppState();
  )
#+END_SRC

+ Creamos el widget _MyAppState e implementamos initState y disponemos además para construir el método por defecto. 

#+BEGIN_SRC dart 
  class _MyAppState extends State<MyApp> with SingleTickerProviderStateMixin{
    Animation<double> animation;
    AnimationController controller;
    @override void initState() {
      super.initState();
      controller = AnimationController(
	duration: const Duration(seconds: 10), vsync: this
      );
      animation = Tween<double>(begin: 0.0, end: 1.0).animate(controller);
      controller.forward();
    }
    // Este widget es el raíz de nuetra aplicación
    @override
    Widget build(BuildContext context){
      controller.forward();
      return MaterialApp(
	title: 'Flutter Demo',
	theme: ThemeData(primarySwatch: Colors.blue,),
	home: MyHomePage(title: 'Product layout demo home page', animation: animation, )
      );
    }
    @override
    void dispose(){
      controller.dispose();
      super.dispose();
    }
  }
#+END_SRC


Aquí 

+ En el método /initState/, hemos creado un controlador para la animación (controlador), un objeto animación (animación) y empezamos la animación usando /controller.forward/. 

+ En el método /dispose/, hemos dispuesto el objeto controlador de la animación (controlador).

+ En el método /build/, enviamos la animación al widget /MyHomePage/ a través del constructor. Ahora, el widget /MyHomePage/ puede usar el objeto animación para animar su contenido. 

+ Ahora, añadiremos el widget /ProductBox/ 

#+BEGIN_SRC dart 
  class ProductBox extends StatelessWidget{
    ProductBox({Key key, this.name, this.description, this.price, this.image}) : super(key: key);
    final String name;
    final String description;
    final int price;
    final String image;

    Widget build(BuildContext context){
      return Container(
	padding: EdgeInsets.all(2),
	height: 140,
	child: Card(
	  child: Row(
	    mainAxisAlignment: MainAxisAlignment.spaceEvenly,
	    children: <Widget>[
	      Image.asset("assets/appimages/" + image),
	      Expanded(
		child: Container(
		  padding: EdgetInsets.all(5),
		  child: Column(
		    mainAxisAlignment: MainAxisAlignment.spaceEVenly,
		    children: <Widget>[
		      Text(this.name, style:
			TextStyle(fontWeight: FontWeight.bold)),
		      Text(this.description),
		      Text("Price: " + this.price.toString()),
		    ],
		  )
		)
	      )
	    ]
	  )
	)
      );
    }
  }
#+END_SRC

Creamos un nuevo Widget, /MyAnimatedWidget/ para hacer una simple animación de desaparición usando opacidad. 


#+BEGIN_SRC dart 
  class MyAnimatedWidget extends StatelessWidget {
    MyAnimatedWidget({this.child, this.animation});

    final Widget child;
    final Animation<double> animation;

    Widget build(BuildContext context) => Center(
      child: AnimatedBuilder(
	animation: animation,
	builder: (context, child) => Container(
	  child: Opacity(opacity: animation.value child: child),
	),
	child: child,
      );
    )
  }
#+END_SRC

+ Aquí, hemos usado /AnimatedBuilder/ para hacer nuestra animación. /AnimatedBuilder/ es un widget el cual construye su contenido mientras hace la animación al mismo tiempo. Acepta un objeto animación para obtener el valor actual de la animación. Hemos usado el valor de la animación, /animation.value/ para establecer la opacidad del widget /child/. En efecto, el widget animará el widget /child/ usando el concepto de opacidad. 
+ Finalmente, creamos el widget /MyHomePage/ y usamos el objeto animación para animar su contenido. 

#+BEGIN_SRC dart 
  class MyHomePage extends StatelessWidget{
    MyHomePage({Key key, this.title, this.animation}) : super(key: key);

    final String title;
    final Animation<double>
    animation;

    @override
    Widget build(BuildContext context){
      return Scaffold(
	appBar: AppBar(title: Text("Product Listing")),body: ListView(
	  shrinkWrap: true,
	  padding: const EdgeInsets.fromLTRB(2.0, 10.0, 2.0, 10.0),
	  children: <Widget>[
	    FadeTransition(
	      child: ProductBox(
		name: "iPhone",
		description: "iPhone is the stylist phone ever",
		price: 1000,
		image: "iphone.png"
	      ), opacity: animation
	    ),
	    MyAnimatedWidget(child: ProductBox(
		name: "Pixel",
		description: "Pixel is the most featureful phone ever",
		price: 800,
		image: "pixel.png"
	    ), animation: animation),
	    ProductBox(
	      name: "Laptop",
	      description: "Laptop is most productive development tool",
	      price: 2000,
	      image: "laptop.png"
	    ),
	    ProductBox(
	      name: "Tablet",
	      description: "Tablet is the mos useful device ever for meeting",
	      price: 1500,
	      image: "tablet.png"
	    ),
	    ProductBox(
	      name: "Pendrive",
	      description: "Pendrive is useful storage medium",
	      price: 100,
	      image: "pendrive.png"
	    ),
	    ProductBox(
	      name: "Floppy Drive",
	      description: "Floppy drive is useful rescue storage medium",
	      price: 20,
	      image: "floppy.png"
	    ),
	  ],
	)
      );
    }
  }
#+END_SRC


Aquí, hemos usado /FadeAnimation/ y /MyAnimationWidget/ para animar el primer elemento de la lista. /FadeAnimation/ es una clase de animación construida, la cual hemos usado para animar su hijo usando el concepto de opacidad. 

+ El código completo es el siguiente: - 

#+BEGIN_SRC dart 

  import 'package:flutter/material.dart'; 
  void main() => runApp(MyApp()); 

  class MyApp extends StatefulWidget { 
     _MyAppState createState() => _MyAppState(); 
  } 
  class _MyAppState extends State<MyApp> with SingleTickerProviderStateMixin {
     Animation<double> animation; 
     AnimationController controller; 
   
     @override 
     void initState() {
	super.initState(); 
	controller = AnimationController(
	   duration: const Duration(seconds: 10), vsync: this); 
	animation = Tween<double>(begin: 0.0, end: 1.0).animate(controller); 
	controller.forward(); 
     } 
     // This widget is the root of your application. 
     @override 
     Widget build(BuildContext context) {
	controller.forward(); 
	return MaterialApp( 
	   title: 'Flutter Demo', theme: ThemeData(primarySwatch: Colors.blue,), 
	   home: MyHomePage(title: 'Product layout demo home page', animation: animation,) 
	); 
     } 
     @override 
     void dispose() {
	controller.dispose();
	super.dispose(); 
     } 
  }
  class MyHomePage extends StatelessWidget { 
     MyHomePage({Key key, this.title, this.animation}): super(key: key);
     final String title; 
     final Animation<double> animation; 
   
     @override 
     Widget build(BuildContext context) {
	return Scaffold(
	   appBar: AppBar(title: Text("Product Listing")), 
	   body: ListView(
	      shrinkWrap: true, 
	      padding: const EdgeInsets.fromLTRB(2.0, 10.0, 2.0, 10.0), 
	      children: <Widget>[
		 FadeTransition(
		    child: ProductBox(
		       name: "iPhone", 
		       description: "iPhone is the stylist phone ever", 
		       price: 1000, 
		       image: "iphone.png"
		    ), 
		    opacity: animation
		 ), 
		 MyAnimatedWidget(
		    child: ProductBox( 
		       name: "Pixel", 
		       description: "Pixel is the most featureful phone ever", 
		       price: 800, 
		       image: "pixel.png"
		    ), 
		    animation: animation
		 ), 
		 ProductBox( 
		    name: "Laptop", 
		    description: "Laptop is most productive development tool", 
		    price: 2000, 
		    image: "laptop.png"
		 ), 
		 ProductBox(
		    name: "Tablet",
		    description: "Tablet is the most useful device ever for meeting",
		    price: 1500, 
		    image: "tablet.png"
		 ), 
		 ProductBox(
		    name: "Pendrive", 
		    description: "Pendrive is useful storage medium", 
		    price: 100, 
		    image: "pendrive.png"
		 ), 
		 ProductBox(
		    name: "Floppy Drive", 
		    description: "Floppy drive is useful rescue storage medium", 
		    price: 20, 
		    image: "floppy.png"
		 ), 
	      ], 
	   )
	); 
     } 
  } 
  class ProductBox extends StatelessWidget { 
     ProductBox({Key key, this.name, this.description, this.price, this.image}) :
	super(key: key);
     final String name; 
     final String description; 
     final int price; 
     final String image; 
     Widget build(BuildContext context) {
	return Container(
	   padding: EdgeInsets.all(2), 
	   height: 140, 
	   child: Card(
	      child: Row(
		 mainAxisAlignment: MainAxisAlignment.spaceEvenly, 
		 children: <Widget>[ 
		    Image.asset("assets/appimages/" + image), 
		    Expanded(
		       child: Container( 
			  padding: EdgeInsets.all(5), 
			  child: Column( 
			     mainAxisAlignment: MainAxisAlignment.spaceEvenly, 
			     children: <Widget>[ 
				Text(
				   this.name, style: TextStyle(
				      fontWeight: FontWeight.bold
				   )
				), 
				Text(this.description), Text(
				   "Price: " + this.price.toString()
				), 
			     ], 
			  )
		       )
		    ) 
		 ]
	      )
	   )
	); 
     } 
  }
  class MyAnimatedWidget extends StatelessWidget { 
     MyAnimatedWidget({this.child, this.animation}); 
     final Widget child; 
     final Animation<double> animation; 
 
     Widget build(BuildContext context) => Center( 
	child: AnimatedBuilder(
	   animation: animation, 
	   builder: (context, child) => Container( 
	      child: Opacity(opacity: animation.value, child: child), 
	   ), 
	   child: child
	), 
     ); 
  }
#+END_SRC


Compilando y ejecutando la aplicación para ver el resultado. La versión inicial y final de la aplicación es la siguiente - 

[[./images/version-inicial.png]]

[[./images/version-final.png]]



